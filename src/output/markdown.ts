import type { AuditReport, Finding, SeverityLevel } from '../models.js';

const LEVEL_EMOJI: Record<SeverityLevel, string> = {
  block: 'ðŸ”´',
  critical: 'ðŸŸ ',
  warning: 'ðŸŸ¡',
  info: 'ðŸ”µ',
};

const LEVEL_NAMES: Record<SeverityLevel, string> = {
  block: 'BLOCKED',
  critical: 'CRITICAL',
  warning: 'WARNING',
  info: 'INFO',
};

/**
 * Generate markdown report from audit results
 */
export function generateMarkdown(report: AuditReport): string {
  const lines: string[] = [];

  // Header
  lines.push('# Antenna Security Audit Report');
  lines.push('');
  lines.push(`**Host:** ${report.hostname}`);
  lines.push(`**Date:** ${report.timestamp}`);
  lines.push(`**Score:** ${report.score}/100`);
  lines.push('');

  // Summary
  lines.push('## Summary');
  lines.push('');
  lines.push(`| Level | Count |`);
  lines.push(`|-------|-------|`);
  lines.push(`| ${LEVEL_EMOJI.block} Blocked | ${report.summary.blocked} |`);
  lines.push(`| ${LEVEL_EMOJI.critical} Critical | ${report.summary.critical} |`);
  lines.push(`| ${LEVEL_EMOJI.warning} Warning | ${report.summary.warnings} |`);
  lines.push(`| ${LEVEL_EMOJI.info} Info | ${report.summary.info} |`);
  lines.push('');

  // Group findings by level
  const byLevel = new Map<SeverityLevel, Finding[]>();
  for (const finding of report.findings) {
    const existing = byLevel.get(finding.level) ?? [];
    existing.push(finding);
    byLevel.set(finding.level, existing);
  }

  // Findings by level
  const levels: SeverityLevel[] = ['block', 'critical', 'warning', 'info'];

  for (const level of levels) {
    const findings = byLevel.get(level);
    if (!findings || findings.length === 0) continue;

    lines.push(`## ${LEVEL_EMOJI[level]} ${LEVEL_NAMES[level]}`);
    lines.push('');

    for (const finding of findings) {
      lines.push(`### ${finding.id}: ${finding.title}`);
      lines.push('');
      lines.push(finding.message);
      lines.push('');

      if (finding.file) {
        lines.push(`**File:** \`${finding.file}\``);
        lines.push('');
      }

      if (finding.details) {
        lines.push(`**Action:** ${finding.details}`);
        lines.push('');
      }

      if (finding.ocsasControl) {
        lines.push(`**OCSAS Control:** ${finding.ocsasControl}`);
        lines.push('');
      }

      if (finding.evidence && finding.evidence.length > 0) {
        lines.push('**Evidence:**');
        for (const e of finding.evidence) {
          lines.push(`- ${e}`);
        }
        lines.push('');
      }
    }
  }

  // Accepted risks
  if (report.acceptedRisks.length > 0) {
    lines.push('## âšª Accepted Risks');
    lines.push('');

    for (const acceptance of report.acceptedRisks) {
      lines.push(`### ${acceptance.id}`);
      lines.push('');
      lines.push(`- **Accepted by:** ${acceptance.accepted_by}`);
      lines.push(`- **Reason:** ${acceptance.reason}`);
      lines.push(`- **Expires:** ${acceptance.expires_at}`);
      if (acceptance.mitigations.length > 0) {
        lines.push(`- **Mitigations:** ${acceptance.mitigations.join(', ')}`);
      }
      lines.push('');
    }
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Generated by [Antenna](https://github.com/NikolayS/antenna)*');

  return lines.join('\n');
}
